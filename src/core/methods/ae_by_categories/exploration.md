<!-- GENERATED: 2026-01-07T19:15:10.872Z -->
<!-- SOURCE: methods.csv + ae-custom-lists.yaml (hash: 54b50899) -->
<!-- DO NOT EDIT MANUALLY - regenerate with: npm run bmad:generate-ae-methods -->

# Exploration Methods

21 methods in the Exploration category.

---

## #101 Quantum Superposition Hold [D]

FORBID collapsing to one solution too early. Maintain minimum 3 solutions in parallel throughout the process. For each: develop independently. Collapse only at the end with justification why NOW

**Pattern:** 3+ parallel solutions → independent development → delayed collapse with justification

---

## #102 Cantor's Diagonal Escape

List N considered approaches. Now CONSTRUCT approach N+1 that DIFFERS from each in at least one aspect. This approach is by definition outside the list — evaluate it honestly

**Pattern:** list of approaches → construct different-from-all → evaluate outsider

---

## #103 Fourier Domain Shift

Reformulate problem in DIFFERENT DOMAIN: (1) if thinking about STRUCTURE → think about FLOW (2) if about DATA → think about PROCESS (3) if about NOW → think about EVOLUTION. Hidden patterns become visible

**Pattern:** current domain → identify opposite domain → reformulate → hidden patterns

---

## #104 Heisenberg Trade-off Forcing [D]

Identify 2 goals you're optimizing. PROVE they can be achieved simultaneously OR accept they're in fundamental conflict and CHOOSE consciously what you sacrifice

**Pattern:** 2 goals → compatibility proof OR incompatibility acceptance → conscious trade-off

---

## #105 Epoché Pure Seeing

SUSPEND all assumptions. List 10 things you know about the problem. For each: how do you know? Did you verify? Remove all unverified. What remains?

**Pattern:** assumptions list → source per assumption → verified only → minimal certainty

---

## #106 Plato's Cave Inversion [D]

Describe your solution. Now: this is a SHADOW. What is it a shadow of? What TRUE problem are you trying to solve? Does your solution address the shadow or the source?

**Pattern:** solution description → shadow identification → true problem → alignment check

---

## #107 Aristotle's Four Causes

Analyze solution through 4 causes: (1) MATERIAL — what is it made of? (2) FORMAL — what structure/pattern? (3) EFFICIENT — what creates/causes it? (4) FINAL — what is it for? No answer to any = gap

**Pattern:** material → formal → efficient → final → gaps in understanding

---

## #108 Coincidentia Oppositorum

Find 2 requirements that SEEM contradictory. Seek solution that UNITES them at higher level. If you cannot — are they really contradictory? Maybe poorly defined?

**Pattern:** apparent contradictions → higher synthesis attempt → redefinition or true conflict

---

## #109 Contraposition Inversion

Instead of what leads to success? answer what GUARANTEES failure?. List 5 certain ways to FAIL. Check if your solution contains any of them

**Pattern:** success path → guaranteed failures list → check current solution against failures

---

## #110 Reductio Attack

Assume your solution is the WRONG choice. Build argument why it's the worst possible approach. If argument is convincing — you have a problem. If you can't build it — good sign

**Pattern:** assume solution is wrong → build attack argument → evaluate attack strength

---

## #111 Fixed Point Self-Reference

Can your solution VERIFY ITSELF? If validation method cannot be applied to itself — why do you trust it works on others?

**Pattern:** solution → apply to itself → self-verification or paradox

---

## #112 Topological Invariant [D]

STRETCH the problem — what remains when you ignore implementation details? What is the ESSENCE that survives any transformation? This is your true constraint

**Pattern:** problem → stretch/deform → identify invariant core → true constraints

---

## #113 Symmetry Breaking

List SYMMETRIES in the problem (what can be swapped without changing essence?). Now: which do you BREAK with your solution? Each symmetry break requires justification — why THIS not that?

**Pattern:** symmetries list → which broken by solution → justification per break

---

## #114 Aporia Seeking

SEEK the I don't know moment — place where you lose certainty. This is NOT weakness — it's indicator where true insight lies. List 3 aporias in your reasoning. For each: explore instead of hide

**Pattern:** reasoning → find uncertainty points → explore each aporia → insights

---

## #115 Entropy Audit

Does your solution ADD order to system or INCREASE chaos? Count: new abstractions / new dependencies / new conventions. Each new thing is potential entropy. Justify each addition

**Pattern:** solution → count new elements → entropy added → justify each addition

---

## #116 Potentiality Excavation

Your solution is ACTUALITY. What was its POTENTIALITY? What other forms COULD it take? List 5 unrealized potentials. For each: why not? Conscious choice or accident?

**Pattern:** actual solution → potential alternatives → why not each → conscious vs accidental

---

## #117 Fractal Zoom [V]

Check solution at 3 scales: (1) MICRO — one code fragment/element (2) MESO — module/component (3) MACRO — entire system. Does it look consistent at each scale? Self-similarity = good design

**Pattern:** micro check → meso check → macro check → self-similarity score

---

## #118 Tunnel Through Impossible

Identify constraint that seems ABSOLUTE. Ask: what if it DIDN'T exist?. Describe solution without that constraint. Now: is it really absolute? Maybe there's a workaround (tunnel)?

**Pattern:** absolute constraints → imagine without → tunnel possibilities

---

## #119 Dual Problem Inversion

Every problem has a DUAL problem. If optimizing MINIMIZATION of X → what is MAXIMIZATION of Y that gives same result? Solve the dual — sometimes it's easier

**Pattern:** problem → identify dual → solve dual → map back to original

---

## #120 Deconstruction Seeds

Find INTERNAL TENSION in your solution — place where logic grinds. This is not bug but feature — there's a hidden assumption you can challenge

**Pattern:** solution → internal tensions → hidden assumptions → deconstruct

---

## #146 Assumption Archaeology

Excavate assumptions in three layers: (1) SURFACE — what you consciously assume (2) INHERITED — what you learned from others without questioning (3) INVISIBLE — what someone from different background would question. For each assumption trace origin: when first believed / who taught / ever tested. Stress test each: inversion (what if opposite true) / edge cases / falsification criteria

**Pattern:** surface assumptions → inherited assumptions → invisible assumptions → origin tracing → stress test

---

